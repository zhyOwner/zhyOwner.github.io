<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>读书笔记 on zhySmile</title>
    <link>http://zhanghaiyan.net/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 读书笔记 on zhySmile</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Sun, 08 Jul 2018 22:15:36 +0800</lastBuildDate>
    
	<atom:link href="http://zhanghaiyan.net/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>《人月神话》读书笔记（下）</title>
      <link>http://zhanghaiyan.net/2018/07/08/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8B/</link>
      <pubDate>Sun, 08 Jul 2018 22:15:36 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/07/08/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8B/</guid>
      <description> 《人月神话》读书笔记（下） 带来坏消息的人不受欢迎 “当人们听到某个项目的进度发生了灾难性偏离时，可能会认为项目一定遭受了一系列重大灾难。然而，通常灾祸来自白蚁的肆虐，而不是龙卷风的侵袭。” 一天一天的进度落后是难以识别、不容易防范和难以弥补的。每件事情都只会将某项活动延迟半天或者一天，但是整个进度开始落后了，尽管每次只有一点点。
控制大型项目的第一步是制定进度表。进度表上的每一件事被称为“里程碑”，都有一个日期。选择日期很大程度上依赖于以往经验。 里程碑的选择只有一个原则，那就是必须是具体的、特定的、可度量的时间，能够进行清晰定义。 策划案商定通过、代码编制完成、通过所有测试用例。这些切实的里程碑澄清了那些划分的比较模糊的阶段——疾患、编码和调试。 如果里程碑定义的非常明确，无法自欺欺人时，很少有人会就里程碑的进展弄虚作假。但是如果里程碑很模糊，就常常会得到一份于实际情况不符的报告。毕竟，没有人愿意承受坏消息。
对于大型开发项目中的估计行为，有如下研究结果。 1. 如果在某项活动开始之前就着手估计，并且每两周进行一次仔细的修订。这样，随着开始时间的临近，无论最后情况会变得如何糟糕，它都不会有太大的变化。 2. 活动期间，对时间长短的过高估计会随着活动的进行持续而下降。 3. 过低估计在活动中不会有太大变化，一直到计划的结束日期之前大约三周左右。
好的里程碑对团队来说是一项服务，可以用来向项目经理提出合理要求的一项服务，而模糊的里程碑是难以处理的负担。
不了解，就无法真正拥有 我们编的代码需要向用户诉说自己的“故事”，即使是完全开发给自己使用的程序。因为记忆衰退的规律会是用户——作者失去对程序的了解，于是不得不重拾自己劳动的各个细节。
关于一篇优秀的文档 1. 目的。 主要的功能是什么？开发程序的原因是什么？ 2. 环境。 程序运行在什么样的机器、硬件配置和操作系统上？ 3. 范围。 数据的有效范围是什么？允许现实的合法输出范围是什么？ 4. 实现功能和使用的算法。 精确的阐述它做了什么。 5. “输入——输出”格式。 不许是确切和完整的。 6. 操作指令。 包括控制台及输出内容中正常和异常结束的行为。 7. 选项。 用户的功能选项有哪些？如何在选项之间进行挑选？ 8. 运行时间。 在制定的配置下，解决特定规模问题所需要的时间？ 9. 精度和校验。 期望结果的精确程度？如何进行精度的检测？
人月神话的观点：是与非  同样有两年经验而且在受到同样培训的情况下，优秀的专业程序员的生产率是较差的程序员的10倍。 小型、精干队伍是最好的——思绪尽可能少。 两个人的团队，其中一个是领导者，常常是最佳的人员使用方法。 对于真正意义上的大型系统，小型精干的对于太慢了。 “概念完整性是系统设计中最重要的考虑因素。” 为了获得概念完整性，设计必须由一个人或者具有共识的小型团队来完成。 仅仅通过对编码部分时间的估计，然后库诚意其他部分的相对系数，是无法得出对整项工作的精确估计的。 同优秀的棒球队伍一样，进取对于杰出的软件开发团队是不可缺少的必要品德。 必须有评审机制，使所有成员可以通过它了解真正的状态。处于这个目的，里程碑的进度和完成文档是关键。 Vyssotsky：“我发现在里程碑报告中很容易记录‘计划（老板）的日期’和‘估计（最基层经理的日期）’的日期。项目经理必须停止对估计日期的怀疑。” 对于大型项目，一个对里程碑报告进行维护的计划和控制小组是非常可贵的。  </description>
    </item>
    
    <item>
      <title>《人月神话》读书笔记（上）</title>
      <link>http://zhanghaiyan.net/2018/07/01/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A/</link>
      <pubDate>Sun, 01 Jul 2018 21:42:36 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/07/01/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A/</guid>
      <description>《人月神话》读书笔记（上） 最近在读的一本书是《人月神话》，由于同事买了这本书，所以打算在同事还没有看这本书计划的时候，先借来看完。现在看到了一半，对于本书内容有了大致了解，感觉可以在以后觉得有需要重读此书的时候，再买来看，毕竟是“软工圣经”。
闲话不多说，下面来写一下我目前看到前半部分的一点感触。
《人月神话》这是一本适用于软件开发人员、软件项目经理及系统分析师等 IT 从业者的经典之作。这是一本始发行于1975年的书，里面记载了一篇作者关于20周年纪念版的序言，里面写道“令我惊奇和高兴的是，《人月神话》在20多年后仍然继续流行”。可能作者也没有想到，在40多年后的今天，这本书依然被我们视为经典，广为流传。能做到如此这般，实属不易。我也很惊讶于这本40多年前的书中观点至今读来仍然能给我醍醐灌顶之感。
 关于职业乐趣 对于我来说，当前职业的乐趣是我能亲眼看到自己工作所带来的成果，能看到自己开发的东西对他人是有用的。而且这个职业是需要持续学习的，在自己去钻研，学习一些新东西的时候，我能明显的感觉到自己的成长，很充实。而不是选择去做一条咸鱼。
 关于职业苦恼 针对书中所提到的某些部分，还是有点感触。 “苦恼来自追求完美”。我对这条的感触是，总是感觉自己写的东西不好，在做某些东西的时候，经常会有一些疑惑，纠结。纠结于这样去写出的代码是不是不好，用另一种方式写会不会更好，纠结于某些处理方式，会不会有更优解。很多时候，自己没法做出判断，就选择了其中一种方式，但是就是觉得不完美。 “苦恼来自由他人设定目标、供给资源和提供信息”。我对这条的感触是，经常由于项目进度原因，某些功能本身预留时间就很紧迫，对于工期的报价不能单单针对功能去评估，这一点是我所左右不了的。
  说起工期的估算，本书中讲到一些方面。
缺乏合理的进度安排是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还大，导致这种灾难如此普遍的原因主要有以下5点：
1、对估算技术缺乏有效的研究，更严肃地说，它反映了一种悄无声息，但并不真实的假设——一切都将运作良好；
2、我们采用的估算技术隐含地假设人和月可以互换，错误地将工作进度与工作量相互混淆；
3、对于自己的估算缺乏信心，软件经理通常不会有耐心持续估算这项工作；
4、对进度缺少跟踪和监督；
5、当意识到进度的偏移时，下意识(以及传统)的反应是增加人力。
乐观主义 “计算机还很年轻，程序员更加年轻，而年轻人重视些乐观主义者——无论是什么样的程序，结果是毋庸置疑的：”这次它肯定会运行“，或者“我刚刚找出最后一个错误””。所以估算工期的背后，有一个错误的假设：一切都将运作良好，每一项任务仅花费它所“应该”花费的时间。 现实可能会像计划安排的那样顺利，但是大多数情况下，一切正常的概率非常小。
人月 人月是在估算和进度安排中使用的工作量单位。书中说“用人月作为衡量一项工作的规模是一个危险和带有欺骗性的神话。它暗示着人员数量和时间是可以相互替换的。”
书中说到几种观点：
 人数和时间的互换仅仅适用于某个任务可以分解给参与人员，并且他们之间不需要相互的交流，这在系统编程中几乎是不可能的。  当任务由于次序上的限制不能分解时，人手的添加对进度没有帮助。  对于可以分解，但子任务之间需要相互沟通和交流的任务，必须在计划工作中考虑沟通的工作量。因此，在相同人月的前提下，采用增加人手来减少时间得到的最好情况，还是比未调整前差一些。  相互之间交流的情况更糟一些。如果任务的每个部分必须分别与其他部分单独协作，则工作量按照 n(n-1)/2 递增。所增加的用于沟通的工作量可能会完全抵消对原有任务分解所产生的作用。所以对于这种情况，添加更多的人手，实际上是延长了而不是缩短了时间进度。   重复产生的进度灾难 当一个软件项目落后于进度时，通常的做法是加派人手。这可能有所帮助，却可能无法解决问题。 Brools 法则：向进度落后的项目中增加人手，只会使进度更加落后。 这就是除去了神话色彩的人月。项目的时间依赖于顺序上的限制，人员的最大数量依赖于独立子任务的数量。
总之，缺乏合理的进度安排是造成项目之后的最主要原因，它比其他所有因素加起来的影响还要大。</description>
    </item>
    
    <item>
      <title>《调试九法》读书笔记</title>
      <link>http://zhanghaiyan.net/2018/05/27/%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 27 May 2018 22:43:04 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/05/27/%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>《调试九法》读书笔记 最近一周在读的一本书是《调试九法》，看完此书之后，感觉这就是一本调试界的葵花宝典，虽然作者并不是互联网行业的一员，书众所列举的例子我也不会遇到，但是这套调试方法看下来之后，却有很多共鸣之处，就像书中说的“本书适用于任何人”。
对于这些调试规则，以下我将他们结合到我的行业中，结合自己的思考，整理一下，便于加深理解和以后的二次阅读。
调试规则： 一：理解系统
二：制造失败
三：不要想，而要看
四：分而治之
五：一次只改一个地方
六：保持审计跟踪
七：检查插头
八：获得全新观点
九：如果你不修复 bug，它将依然存在
一：理解系统 我认为调试方法中首要的一个规则就是”理解系统“，没有理解原理之前，很多问题都没有办法去调试。除非是那种显而易见的。
对于平时的 bug 而言，一般情况下分配给自己处理的都是自己所写的逻辑模块的 bug，因此对于那部分的系统来说，是最清楚不过的（当然，假如那个系统是你 N 年前写的东西，估计还需要你再去梳理一下），但是某些情况下也是不尽然的。在这种你需要去修复别人写的东西的 bug的时候，此规则就是你必须去做的了，永远不要犹豫要不要去做这件事，做就是了。
二：制造失败 在 QA 同学提出 bug 之后，我们首先要去“制造失败”。这是我每次接到 bug 之后，肯定会做的一个步骤，尝试去复现 bug，假如这个 bug 每次必现，我会很开心。最起码不需要再去反复和 QA 同学确定细节，要知道，反复确定细节的结果有可能是无用功，并不会提供多大的帮助。
对于一些比较难“制造失败”的 bug，就需要考虑是不是应该去做点什么，让这个 bug 复现的更方便。
说到这就让我想起了之前遇到的一个 bug，那个 bug 不是规律性复现，我每次尝试“制造失败”的时候，都要一遍一遍的重复操作，企图以最快的速度去复现这个 bug，虽然这个方式也是能复现的，但是那个下班之后回到家的夜晚，我的肩膀异常的疼痛，我把这个锅都扔给了这个 bug，却没有意识到是我“制造失败”的过程太艰辛。还是多亏了同事的提醒，我写了一个自动测试工具，代替了我的人工点击，几分钟的工作，直接的结果就是“制造失败”效率提高了，节省了时间，让我能专心在观察 bug 上，并且胳膊也解脱了。
所以在复现问题的过程中假如太麻烦的话，请考虑花几分钟去写个测试工具，你肯定会感谢你自己做的这个决定。
关于书中所说到的“不要模拟失败”，在看的过程中还是有一些疑惑的。引发失败（正确）和模拟失败（错误）这二者之间存在着非常大的差别。对于那种为了排除干扰因素，建立一个小工程去把不相关部分去掉，只单单观察核心的方式，其实并不是“模拟失败”。“模拟失败”的意思是模拟失败机理本身。
三：不要想，而要看 在遇到 bug 之后的一大忌就是直接去怀疑是哪里出的问题，“不要想，而要看”，去确确实实的看到问题是怎么产生的，猜疑是最不可靠的。假如从一开始你就认为这个 bug 一定是某个部分出了问题，那你从一开始就被蒙蔽了双眼，你会戴着有色眼镜去看这个问题，会产生误导，引入歧途。
需要去看到失败是怎么发生的，在哪里发生的，然后去调试，看到是哪里出了问题，顺藤摸瓜，找到问题的源头，从而解决问题。
当然，”不要想，而要看“并不意味着不能做任何猜想。当理解了系统之后，猜测可能很接近事实，但猜测只是为了确定搜索的重点。在尝试修复问题之前，仍需要再次看到失败，以便确认猜测的是正确的。
四：分而治之 这个规则也是调试过程中一个重要的规则。首先要缩小搜索范围，确定出错的大概范围。书中说了一个小游戏，让你的朋友从1-100之间选一个数字，由你来猜，每次你的朋友告诉你是猜高了，还是猜低了，最多只需7次你就会猜到答案。采用二分法的思路，每次猜区域中间的数字。我和我的朋友玩了这个游戏，恰巧的是，我真的花了整整七次，猜到了他的答案（他的答案是66）。任何有效的目标搜索都会使用一种共同的技术，那就是”逐次逼近“。
还有就是当你去查找这个 bug 的过程中，假如发现了别的 bug ，需要先去修复那个已知 bug，有可能正是这个已知 bug 导致了那个 bug，我在工作的过程中也经常会遇到这样的情况，很多时候，修复了已知的 bug，原 bug 也就迎刃而解了。</description>
    </item>
    
  </channel>
</rss>