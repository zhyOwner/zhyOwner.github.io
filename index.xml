<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zhySmile</title>
    <link>http://zhanghaiyan.net/</link>
    <description>Recent content on zhySmile</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Sun, 09 Sep 2018 21:15:06 +0800</lastBuildDate>
    
	<atom:link href="http://zhanghaiyan.net/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Unity 之协程</title>
      <link>http://zhanghaiyan.net/2018/09/09/unity-%E4%B9%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sun, 09 Sep 2018 21:15:06 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/09/09/unity-%E4%B9%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description>Unity 之协程 1.什么是协程 协程即协同程序，是一种特殊的函数，能够中断执行当前的代码，直到中断指令结束后再接着执行之前的代码。
2.协程的作用 1. 延时等待一段时间执行代码 2. 等某个操作完成之后再执行后面的代码  3.协程的原理 Unity 在每一帧都会去处理 GameObject 里带有的 Coroutine Function, 直到 Coroutine Function 被执行完毕. 当一个 Coroutine 开始启动时, 它会执行到遇到 yield 为止, 遇到 yield 的时候 Coroutine 会暂停执行, 直到满足 yield 语句的条件, 会开始执行 yield 语句后面的内容, 直到遇到下一个 yield 为止 &amp;hellip; 如此循环直到整个函数结束。 Unity 的协程系统基于 C# 的接口 : IEnumerator, 允许为自己的集合类型编写枚举类. 迭代器模式是通过 IEnumerator 和 IEnumerable 接口及它们的泛型等价物来封装的。如果某个类型实现了 IEnumerable 接口，就意味着它可以被迭代访问。
IEnumerator 接口定义了以向前方式遍历或枚举集合元素的基本底层协议。声明方式如下：
public interface IEnumerator { object Current { get; } bool MoveNext(); void Reset(); }  MoveNext 将当前元素向前移动到下一个位置，如果集合中没有更多的元素，那么它会返回 false。Current 返回当前位置的元素。在取出第一个元素之前，必须先调用 MoveNext——即使是空集合也支持这个操作。调用 Reset 方法的作用是将位置移动回到起点，允许再一次遍历集合。</description>
    </item>
    
    <item>
      <title>Unity UGUI - Dropdown</title>
      <link>http://zhanghaiyan.net/2018/09/05/unity-ugui---dropdown/</link>
      <pubDate>Wed, 05 Sep 2018 22:55:59 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/09/05/unity-ugui---dropdown/</guid>
      <description>UGUI 组件之 Dropdown 下拉框 前些日子在工作中遇到一个 Bug，是一个下拉框，第一次打开界面，点击下拉框，会触发正常的下拉框点击事件，不会触发到下拉框展开之后层级底下的按钮点击事件。但是当切换别的界面之后，再点击下拉框，下拉框点击事件就不会再触发，相反，下层按钮点击事件会触发。
看到这个 bug，首先想到的就是有可能是层级问题导致。然后去查代码，发现这个下拉框的实现是通过 UGUI 的 Dropdown 组件。之前并没有用过这个组件，对它的实现原理不了解。去复现问题发现原本下拉列表上没有 Canvas 组件，但是在下拉框展开之后，会给下拉列表添上一个 Canvas 组件，并且其 sortingOrder 很大，为30000。当打开别的界面之后，再点击下拉列表，其 sortingOrder 变小了，查找发现等于其父物体上 Canvas sortingOrder 的值。如此一来，就导致了层级错误，触发事件出问题。
接着我去查看 Dropdown 的源码，在第一次 Dropdown Show 的时候会去初始化下拉列表，添加 Canvas ，设置 sortingOrder = 30000，并且生成一个 Blocker 在根 Canvas 下，设置其 sortingOrder = (Dropdown Canvas).sortingOrder - 1，即 29999。我猜想这么设值的原因是，3000 足够大，能够保证下拉框是最上层，添加 Blocker 是为了防止点击到下层物体。
但是问题出在，我们的 UI 会根据界面展示时机去设置其 Canvas 的 sortingOrder，当打开别的界面返回的时候，会给这个下拉框的 sortingOrder 设置为和根 Canvas 相同的值，打开下拉框的时候，再次生成 Blocker 并设置 sortingOrder，就会造成遮挡功能失效，Bug 出现。
最终的解决方案是必要的时候手动再去设置下拉列表的 sortingOrder。</description>
    </item>
    
    <item>
      <title>Unity 接入 Android SDK，切换黑屏问题</title>
      <link>http://zhanghaiyan.net/2018/07/22/unity-%E6%8E%A5%E5%85%A5-android-sdk%E5%88%87%E6%8D%A2%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 22 Jul 2018 20:56:10 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/07/22/unity-%E6%8E%A5%E5%85%A5-android-sdk%E5%88%87%E6%8D%A2%E9%BB%91%E5%B1%8F%E9%97%AE%E9%A2%98/</guid>
      <description>Unity 接入 Android SDK，切换黑屏问题 问题描述：在 Unity 接入Android SDK 以后，打开 SDK 界面（例如登陆或支付），切换到后台，回来之后游戏背景黑屏问题（SDK 的界面还在，游戏内背景黑了）。
原因：有些 SDK 的界面是采用启动一个新的 activity 的方式。所以导致我们在调用 SDK 的时候，游戏本身会调用生命周期的 pause 。这时候按下设备的 home 键，切换到后台，SDK 应该也会调用 pause 。然后重新返回游戏，这时候只有 SDK 会调用 resume，但我们游戏自己的程序并没有调用 resume。
解决方法：在 onPause 和 onStart 里分别判断当前 mainactivity 是否是 SDK 的 activity，假如是，就手动调用游戏 activity 的 onResume。
另附上 Android Activity 生命周期图； </description>
    </item>
    
    <item>
      <title>hexo 博客同步</title>
      <link>http://zhanghaiyan.net/2018/07/15/hexo-%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Sun, 15 Jul 2018 22:44:46 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/07/15/hexo-%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%AD%A5/</guid>
      <description>本文适用于：使用 github+hexo 方式搭建博客 默认生成文件结构： scaffolds：脚手架，也就是一个工具模板 scripts：写文件的js，扩展hexo的功能 source：存放博客正文内容 source/_drafts：草稿箱 source/_posts：文件箱 themes：存放皮肤的目录 themes/landscape：默认的皮肤 _config.yml：全局的配置文件 db.json：静态常量   关于 _posts 目录：Hexo 是一个静态博客框架，因此没有数据库。文章内容都是以文本文件方式进行存储的，直接存储在 _posts 的目录。Hexo 天生集成了 markdown，我们可以直接使用 markdown 语法格式写博客，新增加一篇文章，就在 _posts 目录，新建一个 xxx.md 的文件。
 关于 _config.yml 文件：它是全局的配置文件，很多的网站配置都在这个文件中定义。
站点信息: 定义标题，作者，语言 URL: URL 访问路径 文件目录: 正文的存储目录 写博客配置：文章标题，文章类型，外部链接等 目录和标签：默认分类，分类图，标签图 归档设置：归档的类型 服务器设置：IP，访问端口，日志输出 时间和日期格式： 时间显示格式，日期显示格式 分页设置：每页显示数量 评论：外挂的 Disqus 评论系统 插件和皮肤：换皮肤，安装插件 Markdown 语言：markdown 的标准 CSS 的 stylus 格式：是否允许压缩 部署配置：github 发布
  同步博客 第一步：原仓库备份博客 （注意：如果 themes/XXX(你使用的皮肤名字目录)下面有 .git，请删除这个 .git 文件夹。不然主题无法 push 到远程仓库，导致你发布的博客是一片空白。）</description>
    </item>
    
    <item>
      <title>《人月神话》读书笔记（下）</title>
      <link>http://zhanghaiyan.net/2018/07/08/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8B/</link>
      <pubDate>Sun, 08 Jul 2018 22:15:36 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/07/08/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8B/</guid>
      <description> 《人月神话》读书笔记（下） 带来坏消息的人不受欢迎 “当人们听到某个项目的进度发生了灾难性偏离时，可能会认为项目一定遭受了一系列重大灾难。然而，通常灾祸来自白蚁的肆虐，而不是龙卷风的侵袭。” 一天一天的进度落后是难以识别、不容易防范和难以弥补的。每件事情都只会将某项活动延迟半天或者一天，但是整个进度开始落后了，尽管每次只有一点点。
控制大型项目的第一步是制定进度表。进度表上的每一件事被称为“里程碑”，都有一个日期。选择日期很大程度上依赖于以往经验。 里程碑的选择只有一个原则，那就是必须是具体的、特定的、可度量的时间，能够进行清晰定义。 策划案商定通过、代码编制完成、通过所有测试用例。这些切实的里程碑澄清了那些划分的比较模糊的阶段——疾患、编码和调试。 如果里程碑定义的非常明确，无法自欺欺人时，很少有人会就里程碑的进展弄虚作假。但是如果里程碑很模糊，就常常会得到一份于实际情况不符的报告。毕竟，没有人愿意承受坏消息。
对于大型开发项目中的估计行为，有如下研究结果。 1. 如果在某项活动开始之前就着手估计，并且每两周进行一次仔细的修订。这样，随着开始时间的临近，无论最后情况会变得如何糟糕，它都不会有太大的变化。 2. 活动期间，对时间长短的过高估计会随着活动的进行持续而下降。 3. 过低估计在活动中不会有太大变化，一直到计划的结束日期之前大约三周左右。
好的里程碑对团队来说是一项服务，可以用来向项目经理提出合理要求的一项服务，而模糊的里程碑是难以处理的负担。
不了解，就无法真正拥有 我们编的代码需要向用户诉说自己的“故事”，即使是完全开发给自己使用的程序。因为记忆衰退的规律会是用户——作者失去对程序的了解，于是不得不重拾自己劳动的各个细节。
关于一篇优秀的文档 1. 目的。 主要的功能是什么？开发程序的原因是什么？ 2. 环境。 程序运行在什么样的机器、硬件配置和操作系统上？ 3. 范围。 数据的有效范围是什么？允许现实的合法输出范围是什么？ 4. 实现功能和使用的算法。 精确的阐述它做了什么。 5. “输入——输出”格式。 不许是确切和完整的。 6. 操作指令。 包括控制台及输出内容中正常和异常结束的行为。 7. 选项。 用户的功能选项有哪些？如何在选项之间进行挑选？ 8. 运行时间。 在制定的配置下，解决特定规模问题所需要的时间？ 9. 精度和校验。 期望结果的精确程度？如何进行精度的检测？
人月神话的观点：是与非  同样有两年经验而且在受到同样培训的情况下，优秀的专业程序员的生产率是较差的程序员的10倍。 小型、精干队伍是最好的——思绪尽可能少。 两个人的团队，其中一个是领导者，常常是最佳的人员使用方法。 对于真正意义上的大型系统，小型精干的对于太慢了。 “概念完整性是系统设计中最重要的考虑因素。” 为了获得概念完整性，设计必须由一个人或者具有共识的小型团队来完成。 仅仅通过对编码部分时间的估计，然后库诚意其他部分的相对系数，是无法得出对整项工作的精确估计的。 同优秀的棒球队伍一样，进取对于杰出的软件开发团队是不可缺少的必要品德。 必须有评审机制，使所有成员可以通过它了解真正的状态。处于这个目的，里程碑的进度和完成文档是关键。 Vyssotsky：“我发现在里程碑报告中很容易记录‘计划（老板）的日期’和‘估计（最基层经理的日期）’的日期。项目经理必须停止对估计日期的怀疑。” 对于大型项目，一个对里程碑报告进行维护的计划和控制小组是非常可贵的。  </description>
    </item>
    
    <item>
      <title>自制小游戏 —— Flappy Bird</title>
      <link>http://zhanghaiyan.net/2018/07/01/%E8%87%AA%E5%88%B6%E5%B0%8F%E6%B8%B8%E6%88%8F--flappy-bird/</link>
      <pubDate>Sun, 01 Jul 2018 23:27:00 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/07/01/%E8%87%AA%E5%88%B6%E5%B0%8F%E6%B8%B8%E6%88%8F--flappy-bird/</guid>
      <description>自己制作的第一款小游戏 背景 制作目的 鉴于自己奋战于游戏行业已经不短时间了，却没有一个人独立的做过一款游戏，实在是有些说不过去。而且游戏领域需要掌握的东西很多很多，明明知道自己还有很多缺失，却又不知该从何学起。本着“从实践中来，到实践中去”的原则，先从一个小游戏开始，发现缺失的东西，后面有针对性的去补。通过调研，觉得这款游戏容易上手，适合做第一款练手游戏，所有选择此游戏。
游戏介绍： 《flappy bird》是一款由来自越南的独立游戏开发者Dong Nguyen所开发的作品，游戏于2013年5月24日上线，并在2014年2月突然暴红。2014年2月，《Flappy Bird》被开发者本人从苹果及谷歌应用商店撤下。2014年8月份正式回归APP STORE，正式加入Flappy迷们期待已久的多人对战模式。游戏中玩家必须控制一只小鸟，跨越由各种不同长度水管所组成的障碍。
项目工程 项目已经发布到 github Releases，项目地址
部分游戏截图： 制作流程 大体思路：
遇到的难点 我在制作这款游戏的过程中还是遇到了一些问题。
 对于游戏主角小鸟的控制。上升与下降的处理。 1.1 刚一开始做的时候，首先的想法是在手指点击之后，给小鸟一个向上的力，通过使用刚体，小鸟根据本身刚体重力的作用去实现下落。这么去做了之后，发现小鸟很不受控制，本身我对于刚体不是很了解，遂弃之。 1.2 第二次尝试，通过插值函数，去设置小鸟的位置。这次的表现比第一次的尝试好一些，但是对比原版，发现原版的小鸟上升时是先快后慢，下降的时候是先慢后快。我理解的插值函数有两种表现：①固定差值步进比例与目标点，变化初始点。这样的结果就是先快后慢变化。②固定初始点与目标点，插值步进比例规律变化。这样的结果是匀速变化。两种插值方式都不满足小鸟先慢后快的下降方式，遂弃之。 1.3 接着尝试了模拟重力加速度的方式，规律变化加速度。给定一个初始值，上升的时候，加速度逐渐变慢，满足小鸟先快后慢的上升方式。等到加速度降到0之后，变为负的，即小鸟开始向下落，加速度逐渐变大，满足小鸟先慢后快的下降方式。最后采用此种方法实现小鸟的运动状态。
 关于图集的处理。 原始素材是一整张的 png，我直接使用了 Unity 的 Sprite Editor 自动切割去切出的小图，这种处理方式是不对的，只是大体上切出了每一个部分，但是不精确。关于图集的切割还有待后续研究。
  总结与反思 关于这自己独立完成的第一款小游戏，用时三周左右，都是在下班之后的时间做的，当然其中不免某些天开个小差。游戏虽小，五脏俱全。从0到1的过程开头是艰难的，一开始做的时候毫无头绪，慢慢去一个点一个点的攻破，发现了很多自己不足的地方，希望下一个游戏，能更加自如的去完成。</description>
    </item>
    
    <item>
      <title>《人月神话》读书笔记（上）</title>
      <link>http://zhanghaiyan.net/2018/07/01/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A/</link>
      <pubDate>Sun, 01 Jul 2018 21:42:36 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/07/01/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8A/</guid>
      <description>《人月神话》读书笔记（上） 最近在读的一本书是《人月神话》，由于同事买了这本书，所以打算在同事还没有看这本书计划的时候，先借来看完。现在看到了一半，对于本书内容有了大致了解，感觉可以在以后觉得有需要重读此书的时候，再买来看，毕竟是“软工圣经”。
闲话不多说，下面来写一下我目前看到前半部分的一点感触。
《人月神话》这是一本适用于软件开发人员、软件项目经理及系统分析师等 IT 从业者的经典之作。这是一本始发行于1975年的书，里面记载了一篇作者关于20周年纪念版的序言，里面写道“令我惊奇和高兴的是，《人月神话》在20多年后仍然继续流行”。可能作者也没有想到，在40多年后的今天，这本书依然被我们视为经典，广为流传。能做到如此这般，实属不易。我也很惊讶于这本40多年前的书中观点至今读来仍然能给我醍醐灌顶之感。
 关于职业乐趣 对于我来说，当前职业的乐趣是我能亲眼看到自己工作所带来的成果，能看到自己开发的东西对他人是有用的。而且这个职业是需要持续学习的，在自己去钻研，学习一些新东西的时候，我能明显的感觉到自己的成长，很充实。而不是选择去做一条咸鱼。
 关于职业苦恼 针对书中所提到的某些部分，还是有点感触。 “苦恼来自追求完美”。我对这条的感触是，总是感觉自己写的东西不好，在做某些东西的时候，经常会有一些疑惑，纠结。纠结于这样去写出的代码是不是不好，用另一种方式写会不会更好，纠结于某些处理方式，会不会有更优解。很多时候，自己没法做出判断，就选择了其中一种方式，但是就是觉得不完美。 “苦恼来自由他人设定目标、供给资源和提供信息”。我对这条的感触是，经常由于项目进度原因，某些功能本身预留时间就很紧迫，对于工期的报价不能单单针对功能去评估，这一点是我所左右不了的。
  说起工期的估算，本书中讲到一些方面。
缺乏合理的进度安排是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还大，导致这种灾难如此普遍的原因主要有以下5点：
1、对估算技术缺乏有效的研究，更严肃地说，它反映了一种悄无声息，但并不真实的假设——一切都将运作良好；
2、我们采用的估算技术隐含地假设人和月可以互换，错误地将工作进度与工作量相互混淆；
3、对于自己的估算缺乏信心，软件经理通常不会有耐心持续估算这项工作；
4、对进度缺少跟踪和监督；
5、当意识到进度的偏移时，下意识(以及传统)的反应是增加人力。
乐观主义 “计算机还很年轻，程序员更加年轻，而年轻人重视些乐观主义者——无论是什么样的程序，结果是毋庸置疑的：”这次它肯定会运行“，或者“我刚刚找出最后一个错误””。所以估算工期的背后，有一个错误的假设：一切都将运作良好，每一项任务仅花费它所“应该”花费的时间。 现实可能会像计划安排的那样顺利，但是大多数情况下，一切正常的概率非常小。
人月 人月是在估算和进度安排中使用的工作量单位。书中说“用人月作为衡量一项工作的规模是一个危险和带有欺骗性的神话。它暗示着人员数量和时间是可以相互替换的。”
书中说到几种观点：
 人数和时间的互换仅仅适用于某个任务可以分解给参与人员，并且他们之间不需要相互的交流，这在系统编程中几乎是不可能的。  当任务由于次序上的限制不能分解时，人手的添加对进度没有帮助。  对于可以分解，但子任务之间需要相互沟通和交流的任务，必须在计划工作中考虑沟通的工作量。因此，在相同人月的前提下，采用增加人手来减少时间得到的最好情况，还是比未调整前差一些。  相互之间交流的情况更糟一些。如果任务的每个部分必须分别与其他部分单独协作，则工作量按照 n(n-1)/2 递增。所增加的用于沟通的工作量可能会完全抵消对原有任务分解所产生的作用。所以对于这种情况，添加更多的人手，实际上是延长了而不是缩短了时间进度。   重复产生的进度灾难 当一个软件项目落后于进度时，通常的做法是加派人手。这可能有所帮助，却可能无法解决问题。 Brools 法则：向进度落后的项目中增加人手，只会使进度更加落后。 这就是除去了神话色彩的人月。项目的时间依赖于顺序上的限制，人员的最大数量依赖于独立子任务的数量。
总之，缺乏合理的进度安排是造成项目之后的最主要原因，它比其他所有因素加起来的影响还要大。</description>
    </item>
    
    <item>
      <title>Unity 接入 Android SDK</title>
      <link>http://zhanghaiyan.net/2018/06/18/unity-%E6%8E%A5%E5%85%A5-android-sdk/</link>
      <pubDate>Mon, 18 Jun 2018 20:00:10 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/06/18/unity-%E6%8E%A5%E5%85%A5-android-sdk/</guid>
      <description>Unity 接入 Android SDK SDK：软件开发工具包（Software Development Kit），软件开发工具包广义上指辅助开发某一类软件的相关文档、范例和工具的集合
需要的开发环境：Unity、安卓开发工具（Eclipse 或 Android Studio） 一、首先阅读文档，有些文档说的不清楚，所以要多读，注意要反复阅读，不要遗漏任何细节 二、将示例 demo 看一遍，查看其调用方式，回调等等 三、接下来步入正轨，开始着手接入
Tips：为了调试的方便，可以先用一个测试小项目接入 SDK，节省调试成本和其余部分的影响，单纯的去测试 SDK 接入，待测试项目通过，再去接入项目内。
接入的SDK 一般分为两种：一种是封装好的适用于 Unity 的。这种就很简单了，只需要去看一下有哪些接口，直接去调用相应的接口就可以了。 但是更多的是另一种，纯 Android 的，这就需要我们去写一些 Android 部分，主要处理 Unity 与 Android 通信的内容。
对于接入纯 Android 的 SDK，我接过的流程如下： 1.创建 Android 工程，写 java 脚本，处理 Unity 与 Android 通信。 2.将 java 脚本打成 jar 包，放入 Unity 工程。 3.Unity 工程里去调用对应方法。
关于 Unity 与 Android 交互： 1.处理 Unity 接收 Android 回调： UnityPlayer.UnitySendMessage(_unityCallBackObjectName, &amp;ldquo;LoginCancelCallBack&amp;rdquo;, &amp;ldquo;&amp;rdquo;); 参数1:GameObject名称，参数2：函数名，参数3:字符串参数。 注意：物体上不存在名称为参数2的函数，不会报错。参数3只能传一个字符串参数，不能传多个，如果需要传多个参数，只能分几个函数调用，或者字符串用特殊字符合并传递再拆分接收。但是参数3不能为null，否则会强制退出。</description>
    </item>
    
    <item>
      <title>Behaviour.enabled、Behaviour.isActiveAndEnabled、GameObject.activeInHierarchy 区别</title>
      <link>http://zhanghaiyan.net/2018/06/10/behaviour.enabledbehaviour.isactiveandenabledgameobject.activeinhierarchy-%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 10 Jun 2018 18:23:01 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/06/10/behaviour.enabledbehaviour.isactiveandenabledgameobject.activeinhierarchy-%E5%8C%BA%E5%88%AB/</guid>
      <description>Behaviour.enabled、Behaviour.isActiveAndEnabled、GameObject.activeInHierarchy 区别 最近在写代码的时候，遇到了三个不太清楚的 API（Behaviour.enabled、Behaviour.isActiveAndEnabled 和 GameObject.activeInHierarchy），去看了 unity 文档，理解的也不是很清楚，于是自己去研究了一下这三个 API 的差异。
一.关于 Behaviour.enabled Unity 官方文档介绍：Enabled Behaviours are Updated, disabled Behaviours are not.
使用这个 API，分别查看脚本所绑定 GameObject 和脚本激活与失活状态下，变量的情况，结果如下：
1.当 GameObject = Active，Script = Enabled 的时候，Behaviour.enabled = true 2.当 GameObject = Active，Script = Disabled 的时候，Behaviour.enabled = false 3.当 GameObject = Inactive，Script = Enabled 的时候，Behaviour.enabled = true 4.当 GameObject = Inactive，Script = Disabled 的时候，Behaviour.enabled = false  结论：Behaviour.enabled 与 GameObject 的状态无关，只与 Script 的状态有关。 ① 当 Script = Enabled，Behaviour.</description>
    </item>
    
    <item>
      <title>Git 常用命令总结</title>
      <link>http://zhanghaiyan.net/2018/06/05/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 05 Jun 2018 22:06:58 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/06/05/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid>
      <description>Git 常用命令总结 仓库  在当前目录新建一个 Git 代码库
 git init   新建一个目录，将其初始化为 Git 代码库
 git init [project-name]   下载一个项目和它的整个代码历史
 git clone [url]   clone 到指定目录
  git clone XXX.git &amp;quot;指定目录&amp;quot;   clone 时创建新的分支替代默认 Origin HEAD(master)
 git clone -b [new_branch_name] xxx.git   clone 远程分支（git clone 命令默认的只会建立 master 分支）,想要 clone 指定的某一远程分支
 git checkout -t origin/dev 或 git checkout -b dev origin/dev  添加/删除文件  添加指定文件到暂存区</description>
    </item>
    
    <item>
      <title>《调试九法》读书笔记</title>
      <link>http://zhanghaiyan.net/2018/05/27/%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 27 May 2018 22:43:04 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/05/27/%E8%B0%83%E8%AF%95%E4%B9%9D%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>《调试九法》读书笔记 最近一周在读的一本书是《调试九法》，看完此书之后，感觉这就是一本调试界的葵花宝典，虽然作者并不是互联网行业的一员，书众所列举的例子我也不会遇到，但是这套调试方法看下来之后，却有很多共鸣之处，就像书中说的“本书适用于任何人”。
对于这些调试规则，以下我将他们结合到我的行业中，结合自己的思考，整理一下，便于加深理解和以后的二次阅读。
调试规则： 一：理解系统
二：制造失败
三：不要想，而要看
四：分而治之
五：一次只改一个地方
六：保持审计跟踪
七：检查插头
八：获得全新观点
九：如果你不修复 bug，它将依然存在
一：理解系统 我认为调试方法中首要的一个规则就是”理解系统“，没有理解原理之前，很多问题都没有办法去调试。除非是那种显而易见的。
对于平时的 bug 而言，一般情况下分配给自己处理的都是自己所写的逻辑模块的 bug，因此对于那部分的系统来说，是最清楚不过的（当然，假如那个系统是你 N 年前写的东西，估计还需要你再去梳理一下），但是某些情况下也是不尽然的。在这种你需要去修复别人写的东西的 bug的时候，此规则就是你必须去做的了，永远不要犹豫要不要去做这件事，做就是了。
二：制造失败 在 QA 同学提出 bug 之后，我们首先要去“制造失败”。这是我每次接到 bug 之后，肯定会做的一个步骤，尝试去复现 bug，假如这个 bug 每次必现，我会很开心。最起码不需要再去反复和 QA 同学确定细节，要知道，反复确定细节的结果有可能是无用功，并不会提供多大的帮助。
对于一些比较难“制造失败”的 bug，就需要考虑是不是应该去做点什么，让这个 bug 复现的更方便。
说到这就让我想起了之前遇到的一个 bug，那个 bug 不是规律性复现，我每次尝试“制造失败”的时候，都要一遍一遍的重复操作，企图以最快的速度去复现这个 bug，虽然这个方式也是能复现的，但是那个下班之后回到家的夜晚，我的肩膀异常的疼痛，我把这个锅都扔给了这个 bug，却没有意识到是我“制造失败”的过程太艰辛。还是多亏了同事的提醒，我写了一个自动测试工具，代替了我的人工点击，几分钟的工作，直接的结果就是“制造失败”效率提高了，节省了时间，让我能专心在观察 bug 上，并且胳膊也解脱了。
所以在复现问题的过程中假如太麻烦的话，请考虑花几分钟去写个测试工具，你肯定会感谢你自己做的这个决定。
关于书中所说到的“不要模拟失败”，在看的过程中还是有一些疑惑的。引发失败（正确）和模拟失败（错误）这二者之间存在着非常大的差别。对于那种为了排除干扰因素，建立一个小工程去把不相关部分去掉，只单单观察核心的方式，其实并不是“模拟失败”。“模拟失败”的意思是模拟失败机理本身。
三：不要想，而要看 在遇到 bug 之后的一大忌就是直接去怀疑是哪里出的问题，“不要想，而要看”，去确确实实的看到问题是怎么产生的，猜疑是最不可靠的。假如从一开始你就认为这个 bug 一定是某个部分出了问题，那你从一开始就被蒙蔽了双眼，你会戴着有色眼镜去看这个问题，会产生误导，引入歧途。
需要去看到失败是怎么发生的，在哪里发生的，然后去调试，看到是哪里出了问题，顺藤摸瓜，找到问题的源头，从而解决问题。
当然，”不要想，而要看“并不意味着不能做任何猜想。当理解了系统之后，猜测可能很接近事实，但猜测只是为了确定搜索的重点。在尝试修复问题之前，仍需要再次看到失败，以便确认猜测的是正确的。
四：分而治之 这个规则也是调试过程中一个重要的规则。首先要缩小搜索范围，确定出错的大概范围。书中说了一个小游戏，让你的朋友从1-100之间选一个数字，由你来猜，每次你的朋友告诉你是猜高了，还是猜低了，最多只需7次你就会猜到答案。采用二分法的思路，每次猜区域中间的数字。我和我的朋友玩了这个游戏，恰巧的是，我真的花了整整七次，猜到了他的答案（他的答案是66）。任何有效的目标搜索都会使用一种共同的技术，那就是”逐次逼近“。
还有就是当你去查找这个 bug 的过程中，假如发现了别的 bug ，需要先去修复那个已知 bug，有可能正是这个已知 bug 导致了那个 bug，我在工作的过程中也经常会遇到这样的情况，很多时候，修复了已知的 bug，原 bug 也就迎刃而解了。</description>
    </item>
    
    <item>
      <title>U3D AssetBundle 官方文档（翻译版）学习笔记</title>
      <link>http://zhanghaiyan.net/2018/05/13/u3d-assetbundle-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 13 May 2018 21:57:23 +0800</pubDate>
      
      <guid>http://zhanghaiyan.net/2018/05/13/u3d-assetbundle-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>AssetBundle 官方文档学习笔记 最近在看何三思翻译的 Unity AssetBundle 官方文档，在此整理一下前半部分笔记
AssetBundles AssetBundle是什么？ 会在运行时被加载的归档文件，包含了和平台相关的特定资源。（Models、Textures、Prefabs、Audio clips、Scenes）
压缩方式？ 根据实际需要，选择引擎内置的算法进行压缩。（LZMA 算法和 LZ4 算法）
作用？ 可下载的内容更新（DLC)、降低初始安装包大小、针对用户平台进行最优化资源加载、降低运行时的内存压力
ssetBundle里有什么？ 1、存储在磁盘上的实际文件，称这种文件为“AssetBundle 归档&amp;rdquo;,里面保存了额外的一些文件。分为两种：序列化文件和资源文件。 2、实际的 AssetBundle 对象。包含了添加到归档中的所有资产（Assets）的文件路径以及与这些资产相对应的对象们这两者之间的映射。 什么是序列化文件？ 用资产组合形成各个对象，将他们写入磁盘中的一个文件，这个文件就是序列化文件。 什么是资源文件？ 一个个二进制数据块，这些数据块分别存储了特定类型的资产，这可以让我们在另一个线程上上更有效的从磁盘中加载它们。
AssetBundle工作流 配置 Assets 到 AssetBundles? 在 Inspector 面板底部，可以设置 AssetBundle 及其变量。左侧设置 AssetBundle，右侧设置变量。下拉选项栏会显示已经注册过的 AssetBundle 的名称选项
AssetBundle 名称？ 支持目录结构。想要添加子文件夹，只需要用”/“分隔文件名称即可。
变量？ 变量名称对创建 AssetBundle 不是必须的。
创建 AssetBundles？ 写一个编辑器脚本 BuildPipeline.BuildAssetBundles(string outputPath, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform)； 所有被命名了的 Assets 都会被构建成对应的 AssetBundle ，并放置在定义的路径下。 加载 AssetBundles 和 Assets? 本地仓库：AssetBundle.LoadFromFile(string path)； 远程仓库：UnityWebRequest.GetAssetBundle(string uri)； DownloadHandlerAssetBundle.</description>
    </item>
    
  </channel>
</rss>